# Ergasia_1_E18030_Antonios_Gantzos
Τεχνική Αναφορά 1ης Εργασίας Πληροφοριακών Συστημάτων 
Ονοματεπώνυμο : Αντώνης Γάντζος
ΑΜ : E18030

*italics*
**bold**
***bold&italic***
// <img src=link>
Σκοπός αυτής της εργασίας είναι η υλοποίηση μιας ιστοσελίδας, η οποία θα επικοινωνεί και θα επεξεργάζεται μία βάση δεδομένων. Η βάση δεδομένων αποτελείται από 2 αρχεία σε μορφή json, το αρχείο students.json και το αρχείο Users.json και για τη κατασκευή της χρησιμοποιήθηκε το εργαλείο docker και το image mongo. 
Για τη δημιουργία ενός docker container, στο οποίο θα δημιουργήσουμε τη βάση δεδομένων χρησιμοποιήθηκε η εντολή ```docker run -d -p 27017:27017 --name mongodb mongo:4.0.4```, με την οποία προσδιορίζουμε το όνομα ης πύλης (port) στην οποία θα βρίσκεται εγκατεστημένο το container μας, δίνουμε στο container το όνομα mongodb και προσδιορίζουμε την έκδοση του mongo, που είναι image που θέλουμε να κάνουμε pull για να εξομοιώσουμε στο container και τέλος φυσικά δημιουργούμε το container. Για να δούμε αν η εντολή εκτελέστηκε με επιτυχία χρησιμοποιούμε την εντολή docker ps -a, η οποία μας δείχνει όλα τα containers που έχουμε δημιουργήσει.
 
Πράγματι παρατηρούμε ότι το container έχει δημιουργηθεί με επιτυχία. Για να δουμε τα περιεχόμενα της βάσης δεδομένων μας χρησιμοποιούμε την εντολή docker exec -it mongodb bash, που μας επιτρέπει να εκτελέσουμε εντολές μέσα από το container. Όταν είμαστε μέσα στο container πληκτρολογούμε την εντολή mongo και μας παραπέμπει στο mongo shell που βρίσκεται μέσα στο container μας. Από το mongo shell λοιπόν, χρησιμοποιούμε την εντολή show dbs, η οποία μας δείχνει όλες τις βάσεις δεδομένων που υπάρχουν στο σύστημα μας.
 
Παρατηρούμε ότι μέσα στις βάσεις δεδομένων βρίσκεται και η βάση InfoSys, την οποία δημιουργήσαμε για τους σκοπούς αυτής της εργασίας. Για να δούμε τα περιεχόμενα της βάσης InfoSys χρησιμοποιούμε την εντολή use InfoSys, που μας δίνει τη δυνατότητα να αναζητήσουμε ότι εμπεριέχεται στη βάση αυτή και την εντολή show collections, που μας δείχνει όλες τις συλλογές δεδομένων που υπάρχουν μέσα σε αυτή τη βάση.
 
Παρατηρούμε λοιπόν ότι στη βάση αυτή βρίσκονται αποθηκευμένες 2 συλλογές δεδομένων, οι οποίες είναι το αρχείο students.json, το οποίο μας είχε δοθεί για τη διεκπεραίωση αυτής της εργασίας και το αρχείο Users.json, το οποίο είναι ένα κενό  αρχείο json που δημιουργήσαμε με σκοπό να λειτουργήσει ως server για την αποθήκευση των usernames και passwords των χρηστών της ιστοσελίδας στα πρώτα endpoints.
Για να δούμε τι περιέχουν τα 2 collections εκτελούμε την εντολή db.Students.find().pretty(), αν θέλουμε να δούμε τι περιέχει το collection Students και db.Users.find().pretty(), αν θέλουμε να δούμε τι περιέχει το collection Users. 
 
Παρατηρούμε ότι στο αρχείο Students βρίσκονται αποθηκευμένες εγγραφές φοιτητών που περιέχουν τις εξής πληροφορίες : ένα μοναδικό id για τον κάθε φοιτητή, το όνομα του φοιτητή, το email του, τη χρονολογία γέννησής του και τη διεύθυνσή του. Το αρχείο Users για την ώρα είναι κενό καθώς δεν έχουμε προσθέσει ακόμα κάποιον χρήστη.
Έχοντας πλέον στήσει τη βάση δεδομένων προχωράμε στην υλοποίηση της ιστοσελίδας, η οποία θα επικοινωνεί με τη βάση μας. Η ιστοσελίδα αποτελείται από 9 endpoints και για τη κατασκευή της χρησιμοποιήθηκε η γλώσσα προγραμματισμού python. 
Θα δούμε πως δουλεύει το κάθε endpoint ξεχωριστά, αλλά χρειάζεται πρώτα να ορίσουμε τον client, δηλαδή τον server στον οποίο βρίσκεται η βάση δεδομένων μας, ο οποίος όπως ορίσαμε πριν είναι το container mongodb μας και βρίσκεται στη πύλη 27.017, επομένως αυτό ορίζουμε ως host της ιστοσελίδας μα, ώστε να λειτουργεί σαν «δίαυλος» επικοινωνίας μεταξύ container και της ιστοσελίδας μας. Ακόμα ορίζουμε τη βάση δεδομένων και τα collections που θα χρησιμοποιήσουμε και θα επεξεργαστούμε στην ιστοσελίδα μας. Χρησιμοποιούμε τη βάση InfoSys και τα collections που δημιουργήσαμε στο container. Έχοντας ορίσει αυτά, μπορούμε να προχωρήσουμε στην υλοποίηση των endpoints της ιστοσελίδας. Για να δοκιμάσουμε αν τα endpoints δουλεύουν με επιτυχία χρησιμοποιούμε την εφαρμογή Postman.  
 

Endpoint 1
Ο στόχος μας για αυτό το endpoint είναι η δημιουργία του username και κωδικού ενός χρήστη και η προσθήκη του στη συλλογή Users. Το username και ο κωδικός δίνονται από τoν χρήστη ως requests σε μορφή json αρχείου χρησιμοποιώντας το παρακάτω κομμάτι κώδικα.
  
Μέσα στη μεταβλητή data περιέχονται α δεδομένα που στέλνει ο χρήστης στην ιστοσελίδα, σε αυτή τη περίπτωση το username και ο κωδικός που επιθυμεί να προστεθούν στη συλλογή Users και ελέγχεται στη συνέχεια από το πρόγραμμα αν η σύνταξη στα δεδομένα είναι σωστή, αν είναι προχωράει στην υλοποίηση του endpoint, αλλιώς στέλνει το κατάλληλο μήνυμα σφάλματος. Το παραπάνω κομμάτι κώδικα χρησιμοποιείται σχεδόν σε όλα τα endpoints και δουλεύει σε όλα με τον ίδιο τρόπο, η μόνη αλλαγή που προκύπτει είναι τα δεδομένα που ελέγχει. 
Στο κύριο κομμάτι του endpoint χρησιμοποιούμε μία συνθήκη if την εντολή users.find({“username”:data[‘username’]}).count(), η οποία θα ψάξει τη συλλογή Users για usernames τα οποία είναι ίδια με αυτό που έστειλε ως request ο χρήστης και μετρά στη συνέχεια τα συνολικά έγγραφα που βρήκε η find. Αν τα αποτελέσματα είναι 0 σημαίνει ότι δεν υπάρχει χρήστης με το ίδιο username αποθηκευμένος στη βάση δεδομένων και το πρόγραμμα κάνει insert το username και τον κωδικό που δόθηκαν ως request από τον χρήστη, διαφορετικά εμφανίζει το κατάλληλο μήνυμα και τον ενημερώνει ότι το username που επέλεξε βρίσκεται ήδη σε χρήση.  
 
Παίρνουμε ένα τυχαίο όνομα, διαλέγουμε έναν κωδικό αυθαίρετα και δοκιμάζουμε το endpoint στο postman. 
 
Παρατηρούμε ότι μας επιστρέφεται μήνυμα επιτυχούς προσθήκης του username και κωδικού του χρήστη από την ιστοσελίδα. Ελέγχουμε και το mongo shell για να βεβαιωθούμε ότι τα αποτελέσματά μας είναι σωστά.
 
Παρατηρούμε ότι το endpoint προστέθηκε στη βάση δεδομένων με επιτυχία. Επειδή δεν ορίσαμε κάποιο id, γίνεται αυτόματα generated.


Endpoint 2
Ο στόχος μας για αυτό το endpoint είναι η αυθεντικοποίηση του username και κωδικού του χρήστη στη βάση δεδομένων και η παραγωγή ενός μοναδικού id για τον χρήστη. Το username και ο κωδικός δίνονται από τoν χρήστη ως requests σε μορφή json και το μοναδικό id παράγεται από την ήδη υλοποιημένη συνάρτηση create_session, που παίρνει ως παράμετρο το username του χρήστη και επιστρέφει ένα μοναδικό id για τον χρήστη.
 
Εργαζόμαστε με ακριβώς ίδιο τρόπο με το endpoint 1, με τη διαφορά ότι αυτή τη φορά ψάχνουμε με κριτήριο και αν υπάρχει το username αλλά και ο κωδικός που ο χρήστης δίνει ως request στη συλλογή Users. . Αν τα αποτελέσματα δεν είναι 0 σημαίνει ότι ο χρήστης είναι αποθηκευμένος στη βάση δεδομένων, το πρόγραμμα κάνει generate το uuid (μοναδικό id) του και του το επιστρέφει, διαφορετικά εμφανίζει το κατάλληλο μήνυμα και τον ενημερώνει ότι το username που επέλεξε δεν βρίσκεται στη βάση δεδομένων, άρα η παραγωγή του μοναδικού id του δεν θα είναι δυνατή.
 
Χρησιμοποιούμε το postman και ελέγχουμε την ορθότητα υλοποίησης του endpoint. Για username χρησιμοποιούμε ενδεικτικά ένα όνομα από το αρχείο students.json, καθώς θα χρειαστούμε το uuid για τα επόμενα endpoints.
 
Παρατηρούμε ότι το endpoint εκτελέστηκε με επιτυχία.

Endpoint 3
Ο στόχος μας για αυτό το endpoint είναι η επιστροφή των στοιχείων ενός φοιτητή δίνοντας ως request μόνο το email του και το uuid που δημιουργήσαμε στο ερώτημα 2 με σκοπό να επιβεβαιώσουμε ότι ο χρήστης είναι αυθεντικοποιημένος. Για να το κάνουμε αυτό χρησιμοποιούμε την ήδη υλοποιημένη συνάρτηση is_session_valid, η οποία παίρνει ως παράμετρο το uuid ου endpoint 2 και επιστρέφει μία Boolean τιμή ανάλογα με το αν ισχύει ακόμα η όχι. Εκτελούμε την ίδια διαδικασία για όλα τα παρακάτω ερωτήματα.
 
Το uuid το περνάμε σαν request στο postman ως εξής. Μεταβαίνουμε στην επιλογή headers και στη στήλη keys πληκτρολογούμε authorization και στην στήλη values το uuid του endpoint 2 και το στέλνουμε έτσι μαζί με το json αρχείο που περιέχει το email του φοιτητή στην ιστοσελίδα.
 
Ελέγχουμε λοιπόν αν το uuid είναι έγκυρο. Αν είναι χρησιμοποιούμε την εντολή students.find_one({“email:data[‘email’]”}), η οποία θα ελέγξει την συλλογή students, όπου βρίσκονται οι εγγραφές των φοιτητών και θα μας επιστρέψει τα στοιχεία ενός φοιτητή, ο οποίος έχει το email που έδωσε σαν request ο χρήστης. Φορτώνουμε τα στοιχεία αυτά σε json μορφή και αν το αρχείο αυτό δεν είναι κενό η ισοσελίδα μας επιστρέφει όλα τα στοιχεία του φοιτητή που βρέθηκαν, αλλιώς μας εμφανίζει το κατάλληλο μήνυμα. Αυτά γίνονται σε περίπτωση που το uuid είναι έγκυρο. Αν δεν είναι έγκυρο εμφανίζεται το κατάλληλο μήνυμα στον χρήστη.
 
Ελέγχουμε την εγκυρότητα του endpoint στο postman αφού δίνοντας ως request ένα email από το αρχείο students.json το οποίο είναι από την εγγραφή του φοιτητή που χρησιμοποιήσαμε για το endpoint 2.
 
Παρατηρούμε ότι το endpoint εκτελέστηκε με επιτυχία.

Endpoint 4
Ο στόχος μας για αυτό το endpoint είναι η επιστροφή όλων των φοιτητή που είναι 30 χρονών, δίνοντας ως request το αρχείο students.json για να δοκιμάσουμε την εγκυρότητα των αποτελεσμάτων μας, καθώς και το uuid για να επιβεβαιωθούμε για το αν ο χρήστης είναι αυθεντικοποιημένος.
Ελέγχουμε αν το uuid είναι έγκυρο. Αν είναι χρησιμοποιούμε την εντολή students.find(“yearOfBirth”:1991), η οποία ψάχνει στη συλλογή students και μας επιστρέφει τα στοιχεία όλων των φοιτητών που είναι εγγεγραμένοι ως γεννημένοι το 1991, όσοι είναι δηλαδή ακριβώς 30 χρονών και αποθηκεύουμε τα αποτελέσματα αυτά σε μία μεταβλητή. Χρησιμοποιούμε την εντολή count() και μετράμε τον αριθμό των εγγραφών που βρέθηκαν. Αν οι εγγραφές είναι 0, δηλαδή δεν υπάρχουν μαθητές γεννημένοι το 1991, επιστρέφεται το κατάλληλο μήνυμα στον χρήστη. Αν υπάρχουν τότε χρησιμοποιούμε μία λίστα και αντιγράφουμε τα αποτελέσματα που αποθηκεύσαμε προηγουμένως σε αυτή σε αυτή. Αυτή τη λίστα τη στέλνουμε ως αποτέλεσμα στον χρήστη.  Αυτά γίνονται σε περίπτωση που το uuid είναι έγκυρο. Αν δεν είναι έγκυρο εμφανίζεται το κατάλληλο μήνυμα στον χρήστη.
 

Ελέγχουμε την εγκυρότητα του endpoint στο postman.
 
Παρατηρούμε ότι το endpoint υλοποιήθηκε με επιτυχία.

Endpoint 5
Ο στόχος μας για αυτό το endpoint είναι η επιστροφή όλων των φοιτητή που είναι άνω των 30 χρονών, δίνοντας ως request το αρχείο students.json για να δοκιμάσουμε την εγκυρότητα των αποτελεσμάτων μας, καθώς και το uuid για να επιβεβαιωθούμε για το αν ο χρήστης είναι αυθεντικοποιημένος.
Ελέγχουμε αν το uuid είναι έγκυρο. Αν είναι χρησιμοποιούμε την εντολή students.find(“yearOfBirth”:{“$lte” : 1991} ), η οποία ψάχνει στη συλλογή students και μας επιστρέφει τα στοιχεία όλων των φοιτητών που είναι εγγεγραμένοι ως γεννημένοι από το 1991 και πριν , όσοι είναι δηλαδή 30 χρονών ή περισσότερο και αποθηκεύουμε τα αποτελέσματα αυτά σε μία μεταβλητή. Χρησιμοποιούμε την εντολή count() και μετράμε τον αριθμό των εγγραφών που βρέθηκαν. Αν οι εγγραφές είναι 0, δηλαδή δεν υπάρχουν μαθητές γεννημένοι το 1991 ή από προηγούμενα έτη, επιστρέφεται το κατάλληλο μήνυμα στον χρήστη. Αν υπάρχουν τότε χρησιμοποιούμε μία λίστα και αντιγράφουμε τα αποτελέσματα που αποθηκεύσαμε προηγουμένως σε αυτή σε αυτή. Αυτή τη λίστα τη στέλνουμε ως αποτέλεσμα στον χρήστη.  Αυτά γίνονται σε περίπτωση που το uuid είναι έγκυρο. Αν δεν είναι έγκυρο εμφανίζεται το κατάλληλο μήνυμα στον χρήστη.
 
Ελέγχουμε την εγκυρότητα των αποτελεσμάτων στο postman.
 
 Παρατηρούμε ότι το endpoint εκτελέστηκε με επιτυχία.



Endpoint 6
Ο στόχος μας για αυτό το endpoint είναι η επιστροφή της διεύθυνσης και του ονόματος ενός φοιτητή δίνοντας ως request μόνο το email του και το uuid, με σκοπό να επιβεβαιώσουμε ότι ο χρήστης είναι αυθεντικοποιημένος. Συγκεκριμένα ενδιαφερόμαστε μόνο για την οδό που βρίσκεται το σπίτι του φοιτητή και το ταχυδρομικό του κώδικα.
Ελέγχουμε αν το uuid είναι έγκυρο. Αν είναι χρησιμοποιούμε την εντολή students.find_one({“email:data[‘email’]”}), η οποία θα ελέγξει την συλλογή students, όπου βρίσκονται οι εγγραφές των φοιτητών και θα μας επιστρέψει τα στοιχεία ενός φοιτητή, ο οποίος έχει το email που έδωσε σαν request ο χρήστης. Φορτώνουμε τα στοιχεία αυτά σε json μορφή και αν το αρχείο αυτό δεν είναι κενό, δηλαδή ο αριθμός των εγγραφών που βρέθηκαν δεν είναι 0, η ιστοσελίδα μας το όνομα του φοιτητή, την οδό του και τον ταχυδρομικό του κώδικα. Τα αποτελέσματα αυτά τα εμφανίζουμε ως εξής. Έχουμε αποθηκεύσει όλα τα στοιχεία του φοιτητή, τα οποία είναι σε μορφή dictionary.Δημιουργούμε λοιπόν ένα κενό dictionary, στο οποίο αντιγράφουμε τα αποτελέσματα που μας αφορούν, κρατάμε δηλαδή μόνο τα keys ‘name’ που περιέχει το όνομα του και για την διεύθυνση εργαζόμαστε λίγο διαφορετικά. Το key ‘address’ είναι ουσιαστικά μία λίστα από dictionaries που περιέχει μέσα μόνο ένα dictionary, το οποίο περιέχει τα κλειδιά ‘street’, που είναι η οδός, ‘City’, που είναι η πόλη που διαμένει ο φοιτητής και ‘postcode’, που είναι ο ταχυδρομικός του κώδικας. Εφόσον υπάρχει μόνο ένα dictionary στη λίστα όλα τα κλειδιά μας που εμπεριέχονται σε αυτό βρίσκονται στη θέση [0] της λίστας. Άρα για να πάρουμε το value του κλειδιού ‘street’ ορίζουμε ‘ ότι θα πάρουμε από τη μεταβλητή που έχουμε αποθηκεύσει όλα τα στοιχεία του φοιτητή που βρήκαμε, τη τιμή που βρίσκεται μέσα στη λίστα address στη θέση 0 και το key της έχει το όνομα ‘street’. To ίδιο θα κάνουμε για να πάρουμε και τον ταχυδρομικό κώδικα του φοιτητή. Επιστρέφουμε το dictionary που αντιγράψαμε αυτές τις τιμές στον χρήστη. Αν τα αποτελέσματα εγγραφών που βρέθηκαν είναι 0 εμφανίζεται το κατάλληλο μήνυμα στον χρήστη. Αυτά γίνονται σε περίπτωση που το uuid είναι έγκυρο. Αν δεν είναι έγκυρο εμφανίζεται το κατάλληλο μήνυμα στον χρήστη.

 
Ελέγχουμε την εγκυρότητα του endpoint στο postman.
 

Παρατηρούμε ότι το endpoint υλοποιήθηκε με επιτυχία.

Endpoint 7
Ο στόχος μας για αυτό το endpoint είναι η διαγραφή ενός φοιτητή από τη συλλογή students, δίνοντας ως request μόνο το email του και το uuid, με σκοπό να επιβεβαιώσουμε ότι ο χρήστης είναι αυθεντικοποιημένος.
Ελέγχουμε αν το uuid είναι έγκυρο. Αν είναι χρησιμοποιούμε την εντολή students.find_one({“email:data[‘email’]”}), η οποία θα ελέγξει την συλλογή students, όπου βρίσκονται οι εγγραφές των φοιτητών και θα μας επιστρέψει τα στοιχεία ενός φοιτητή, ο οποίος έχει το email που έδωσε σαν request ο χρήστης. Φορτώνουμε τα στοιχεία αυτά σε json μορφή και χρησιμοποιούμε την συνάρτηση count() για να διαπιστώσουμε αν οι εγγραφές φοιτητών που να ικανοποιούν τη συνθήκη που δώσαμε είναι 0 η όχι.. Αν πράγματι δεν είναι χρησιμοποιούμε την εντολή students.delete_one({"email":data['email']}), η οποία ψάχνει στη συλλογή students για τον φοιτητή στον οποίο ανήκει το email, τον διαγράφει από τη συλλογή και στη συνέχεια στέλνει πίσω το κατάλληλο μήνυμα στον χρήστη. Αν είναι κενό αρχείο η ιστοσελίδα ενημερώνει τον χρήστη ότι δεν υπάρχει κάποιος φοιτητής, στον οποίο να ανήκει αυτό το email. Αυτά γίνονται σε περίπτωση που το uuid είναι έγκυρο. Αν δεν είναι έγκυρο εμφανίζεται το κατάλληλο μήνυμα στον χρήστη.   

Ελέγχουμε την εγκυρότητα του endpoint στο postman.
 
Παρατηρούμε ότι το endpoint υλοποιήθηκε με επιτυχία.

Endpoint 8
Ο στόχος μας για αυτό το endpoint είναι η ενημέρωση των στοιχείων ενός φοιτητή από τη συλλογή students, έτσι ώστε να αποθηκευτούν οι βαθμοί του στα μαθήματα στα οποία έδωσε εξετάσεις, δίνοντας ως request το email του, τους βαθμούς του στα μαθήματα και το uuid, με σκοπό να επιβεβαιώσουμε ότι ο χρήστης είναι αυθεντικοποιημένος. Οι βαθμοί πρέπει να βρίσκονται σε μορφή λίστας που αποθηκεύει dictionaries.
Ελέγχουμε αν το uuid είναι έγκυρο. Αν είναι χρησιμοποιούμε την εντολή students.find_one({“email:data[‘email’]”}), η οποία θα ελέγξει την συλλογή students, όπου βρίσκονται οι εγγραφές των φοιτητών και θα μας επιστρέψει τα στοιχεία ενός φοιτητή, ο οποίος έχει το email που έδωσε σαν request ο χρήστης. Χρησιμοποιούμε την συνάρτηση count() για να διαπιστώσουμε αν οι εγγραφές φοιτητών που να ικανοποιούν τη συνθήκη που δώσαμε είναι 0 η όχι. Αν δεν είναι χρησιμοποιούμε την εντολή students.update_one({"email": data['email']} , {'$set' : { "courses" : data['courses']}}), η οποία ψάχνει στη συλλογή students για τον φοιτητή στον οποίο ανήκει το email και ενημερώνει τα στοιχεία του προσθέτοντας τα μαθήματα που έχει στείλει ως request. Αν είναι κενό αρχείο η ιστοσελίδα ενημερώνει τον χρήστη ότι δεν υπάρχει κάποιος φοιτητής, στον οποίο να ανήκει αυτό το email. Αυτά γίνονται σε περίπτωση που το uuid είναι έγκυρο. Αν δεν είναι έγκυρο εμφανίζεται το κατάλληλο μήνυμα στον χρήστη.  
 
Ελέγχουμε την εγκυρότητα του endpoint στο postman.
 

Κοιτάμε στο mongoshell στο collection Students για το αν προστέθηκαν τα στοιχεία με επιτυχία.
 

Παρατηρούμε ότι τα μαθήματα προστέθηκαν με επιτυχία.

Endpoint 9
Ο στόχος μας για αυτό το endpoint είναι να εμφανιστούν όλα τα περασμένα μαθήματα ενός φοιτητή από τους βαθμούς που αποθηκεύσαμε στο endpoint 8 , δίνοντας ως request μόνο το email του και το uuid, με σκοπό να επιβεβαιώσουμε ότι ο χρήστης είναι αυθεντικοποιημένος.
Ελέγχουμε αν το uuid είναι έγκυρο. Αν είναι χρησιμοποιούμε την εντολή students.find({"$and":[{"email" : data['email']}, {"courses": { "$exists": True }}]}). Η εντολή αυτή ψάχνει τη συλλογή students για να βρει μία εγγραφή φοιτητή, που το email του ταιριάζει με το email που έδωσε ως request ο χρήστης αλλά και αν υπάρχουν αποθηκευμένα τα μαθήματα που έδωσε ο φοιτητής αυτός στα στοιχεία του. 
Χρησιμοποιούμε την συνάρτηση count() για να διαπιστώσουμε αν το αρχείο αυτό δεν είναι κενό. Αν δεν είναι εργαζόμαστε ως εξής. Αρχικά φορτώνουμε όλα τα στοιχεία του φοιτητή με το email που βρέθηκε σε json μορφή και τα αποθηκεύουμε. Στη συνέχεια αντιγράφουμε σε μία λίστα μόνο το key ‘courses’ από τα στοιχεία του φοιτητή. Τα αποθηκεύουμε σε λίστα γιατί, όπως προ-αναφέραμε οι βαθμοί βρίσκονται σε μορφή λίστας. Στη συνέχεια δημιουργούμε ένα κενό dictionary και το ονομάζουμε συμβολικά arr. Εκεί αποθηκεύουμε σε αυτό όλα τα στοιχεία της λίστας μας. Τέλος φτιάχνοντας ένα ακόμα dictionary, που ονομάζουμε συμβολικά arr2, κάνουμε iterate το arr όπου βρίσκονται όλοι οι βαθμοί και με μία απλή συνθήκη if αντιγράφουμε στο arr2 μόνο τους βαθμούς που είναι από 5 και πάνω και αντιπροσωπεύουν τα περασμένα μαθήματα. Επιστρέφουμε το arr2 στον χρήστη. Αν πάλι η συνάρτηση count() μας επιστρέψει 0, τότε η ιστοσελίδα εμφανίζει στον χρήστη κατάλληλο μήνυμα. Αυτά γίνονται σε περίπτωση που το uuid είναι έγκυρο. Αν δεν είναι έγκυρο εμφανίζεται το κατάλληλο μήνυμα στον χρήστη.  

 

Ελέγχουμε την εγκυρότητα του endpoint στο postman. Χρησιμοποιούμε την εγγραφή του φοιτητή στην οποία αποθηκεύσαμε τους βαθμούς στο ερώτημα 8.
 
 
Παρατηρούμε ότι και το endpoint 9 υλοποιήθηκε με επιτυχία.
